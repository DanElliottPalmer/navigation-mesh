<!DOCTYPE html>
<!--[if lt IE 7]> <html class="lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if IE 7]>    <html class="lt-ie9 lt-ie8"> <![endif]-->
<!--[if IE 8]>    <html class="lt-ie9"> <![endif]-->
<!--[if gt IE 8]><!--> <html class=""> <!--<![endif]-->
	<head>  
		<meta charset="utf-8">
		<title></title>
		<meta name="viewport" content="width=device-width, initial-scale=1" />
		<style type="text/css">
			.group {
				border-bottom: 1px solid #ccc;
				padding: 10px 0;
			}
			.group h3 {
				margin: 0 0 10px 0;
			}
		</style>
	</head>
	<body>
		<canvas id="domCanvas" width="800" height="400" style="border: 1px solid #f00"></canvas> <br />

		<div class="group">
			<h3>Mesh</h3>
			<textarea cols="50" rows="10" id="txtInput">{"boundaries":[[[0,2],[1,0]],[[3,1]],[[2,4]],[[5,3]],[],[[7,5]],[[6,8]],[[9,7]],[[8,10]],[[10,11]],[[12,9]],[[13,12]],[[11,6]],[[4,13]]],"neighbours":[[1],[2,0],[1,3],[2,4],[13,3,5],[4,6],[5,7],[8,6],[7,9],[10,8],[11,9],[12,10],[13,11],[4,12]],"points":[[268,343],[79,332],[245,131],[80,53],[504,135],[675,64],[606,262],[691,336],[615,309],[376,336],[434,308],[435,264],[365,233],[505,231]],"triangles":[[0,1,2],[1,3,2],[4,2,3],[5,4,3],[5,6,4],[7,6,5],[7,8,6],[7,9,8],[9,10,8],[10,9,11],[11,9,12],[11,12,13],[11,13,6],[6,13,4]]}</textarea>
			<br />
			<button id="btnParse">Parse</button>
		</div>
		
		<div class="group">
			<h3>Graph network</h3>
			<label for="chkRenderGraph"><input type="checkbox" id="chkRenderGraph" /> Render graph network</label>
		</div>
		
		<div class="group">
			<h3>Pathfinding</h3>
			<label for="chkRandomPoints"><input type="checkbox" id="chkRandomPoints" /> Test random points</label> <br />
			<!-- <button id="btnStart">Start point</button>
			<button id="btnEnd">End point</button>
			<button id="btnPath">Show path</button> -->
		</div>
		
		<script src="dist/NavigationMesh.js"></script>
		<script type="text/javascript">

			var isGraphParsed = false;
			var testRandomPoints = false;

			var tmrRandomPoints = null;

			var isRenderGraph = false;

			var mesh = null;
			var path = null;

			document.getElementById("chkRenderGraph").addEventListener("change", function onRenderGraphChange(){
				isRenderGraph = this.checked;
			});

			document.getElementById("chkRandomPoints").addEventListener("change", function onTestPointsChange(){
				testRandomPoints = this.checked;
				if( !testRandomPoints && tmrRandomPoints !== null ){
					clearInterval( tmrRandomPoints );
					tmrRandomPoints = null;
					return;
				}
				if( isGraphParsed ){
					randomPointTest();
					tmrRandomPoints = setInterval( randomPointTest, 3000 );
				}
			});

			document.getElementById("btnParse").addEventListener("click", function(){
				mesh = new NavigationMesh();
				mesh.parse( JSON.parse( document.getElementById("txtInput").value ) );
				isGraphParsed = true;
			});

			function randomPointTest(){
				// Get random triangle for the start and end
				var startRandomTri = mesh.triangles[ ~~random( 0, mesh.triangles.length ) ];
				var endRandomTri = mesh.triangles[ ~~random( 0, mesh.triangles.length ) ];
				// Get random point in triangle
				var startPoint = randomPointInTriangle(
					[ startRandomTri.points[0].x, startRandomTri.points[0].y ],
					[ startRandomTri.points[1].x, startRandomTri.points[1].y ],
					[ startRandomTri.points[2].x, startRandomTri.points[2].y ]
				);
				var endPoint = randomPointInTriangle(
					[ endRandomTri.points[0].x, endRandomTri.points[0].y ],
					[ endRandomTri.points[1].x, endRandomTri.points[1].y ],
					[ endRandomTri.points[2].x, endRandomTri.points[2].y ]
				);

				console.clear();
				path = mesh.calculatePath( new NavigationPoint( startPoint[0], startPoint[1] ), new NavigationPoint( endPoint[0], endPoint[1] ) );
			}

			function random( min, max ){
				return min + Math.random() * ( max - min );
			}

			function randomPointInTriangle( a, b, c ){
			
				var ab = [0,0];
				var ac = [0,0];

				ab[0] = b[0] - a[0];
				ab[1] = b[1] - a[1];
				ac[0] = c[0] - a[0];
				ac[1] = c[1] - a[1];

				var r = random( 0, 1 );
				var s = random( 0, 1 );

				if( r + s >= 1 ){
					r = 1 - r;
					s = 1 - s;
				}

				ab[0] *= r;
				ab[1] *= r;
				ac[0] *= s;
				ac[1] *= s;

				return [
					a[0] + ab[0] + ac[0],
					a[1] + ab[1] + ac[1]
				];

			}

			/**
			 * DEBUG RENDER BITS
			 */
			
			var domCanvas = document.getElementById("domCanvas");
			var ctx = domCanvas.getContext("2d");
			var width = domCanvas.width;
			var height = domCanvas.height;

			function clear(){
				ctx.clearRect( 0, 0, width, height );
			}

			function loop(){
				requestAnimationFrame( loop );
				clear();
				renderTriangles();
				renderGraph();
				renderPath();
			}

			function renderGraph(){
				if( !isRenderGraph || mesh === null ) return;
				ctx.save();
				// Render nodes
				ctx.fillStyle = "#0f0";
				ctx.globalAlpha = 0.5;
				mesh.graph.nodes.forEach(function eachNode( node ){
					ctx.beginPath();
					ctx.arc( node.x, node.y, 10, 0, Math.PI*2, false );
					ctx.closePath();
					ctx.fill();
				});
				ctx.restore();
			}

			function renderPath(){
				if( path === null ) return;
				ctx.save();
				ctx.strokeStyle = "#00f";
				ctx.lineWidth = 2;
				ctx.beginPath();
				path.forEach(function eachPathPoint( point, index ){
					if( index === 0 ){
						ctx.moveTo( point.x, point.y );
						return;
					}
					ctx.lineTo( point.x, point.y );
				});
				ctx.stroke();
				ctx.restore();
			}

			function renderTriangles(){
				if( mesh === null ) return;
				ctx.save();
				ctx.strokeStyle = "#f00";
				ctx.lineWidth = 1;
				mesh.triangles.forEach(function eachTriangle( triangle ){
					ctx.beginPath();
					triangle.points.forEach(function eachPoint( point, index ){
						if( index === 0 ){
							ctx.moveTo( point.x, point.y );
							return;
						}
						ctx.lineTo( point.x, point.y );
					});
					ctx.closePath();
					ctx.stroke();
				});
				ctx.restore();
			}

			loop();
			
		</script>
	</body>
</html>